diff --git a/addon.xml b/addon.xml
index 1234567..abcdefg 100644
--- a/addon.xml
+++ b/addon.xml
@@ -17,6 +17,7 @@
     </menu>
   </extension>
   <extension point="xbmc.addon.metadata">
+    <reuselanguageinvoker>true</reuselanguageinvoker>
     <summary lang="en">Stream4Me is a Kodi add-on to search and watch contents on the web.</summary>
     <summary lang="it">Stream4Me Ã¨ un addon per Kodi per cercare e guardare contenuti sul web.</summary>
     <assets>
diff --git a/channels/streamingcommunity.py b/channels/streamingcommunity.py
index 1234567..abcdefg 100644
--- a/channels/streamingcommunity.py
+++ b/channels/streamingcommunity.py
@@ -248,6 +248,51 @@ def episodios(item):
     #support.download(itemlist, item)
     return itemlist
 
+
+def find_episode(item, season, episode):
+    """
+    Optimized function to find a specific episode directly without scraping all seasons.
+    Used by TMDb Helper for faster playback initiation.
+    """
+    logger.debug('find_episode', season, episode)
+    try:
+        # Fetch the specific season page
+        season_url = item.url + '/season-' + str(season)
+        data_page = get_data(season_url)
+        
+        if not data_page or 'props' not in data_page or 'loadedSeason' not in data_page['props']:
+            logger.debug("Season data not found")
+            return None
+            
+        episodes = data_page['props']['loadedSeason']['episodes']
+        title_id = data_page['props']['title']['id']
+        
+        for ep in episodes:
+            if int(ep['number']) == int(episode):
+                title = item.fulltitle or item.title
+                ep_title = ep['name']
+                
+                return item.clone(
+                    title=support.typo(f"{season}x{str(episode).zfill(2)} - {support.cleantitle(ep_title)}", 'bold'),
+                    episode=ep['number'],
+                    season=season,
+                    contentSeason=season,
+                    contentEpisodeNumber=ep['number'],
+                    thumbnail=ep['images'][0].get('original_url', item.thumbnail) if ep['images'] else item.thumbnail,
+                    contentThumbnail=item.thumbnail,
+                    fanart=item.fanart,
+                    contentFanart=item.fanart,
+                    plot=ep['plot'],
+                    action='findvideos',
+                    contentType='episode',
+                    contentSerieName=title,
+                    url='{}/it/iframe/{}?episode_id={}'.format(host, title_id, ep['id'])
+                )
+    except:
+        import traceback
+        logger.error(traceback.format_exc())
+    
+    return None
+
 
 def findvideos(item):
     support.callAds('https://thaudray.com/5/3523301', host)
diff --git a/platformcode/launcher.py b/platformcode/launcher.py
index 1234567..abcdefg 100644
--- a/platformcode/launcher.py
+++ b/platformcode/launcher.py
@@ -538,3 +538,115 @@ def findvideos(item, itemlist=[]):
         platformtools.dialog_notification(config.get_localized_string(20000), config.get_localized_string(
 
 
+def play_movie_direct(item):
+    """
+    Direct movie playback from TMDb Helper.
+    Searches for a movie on the specified channel and plays it directly.
+    """
+    logger.debug('play_movie_direct called with:', item.tostring())
+    
+    channel_name = item.channel if item.channel else 'streamingcommunity'
+    search_text = item.text if item.text else ''
+    year = str(item.year) if item.year else ''
+    
+    if not search_text:
+        platformtools.dialog_notification(config.get_localized_string(20000), 'No movie name provided')
+        return
+    
+    try:
+        channel = importChannel(Item(channel=channel_name))
+        if not channel:
+            platformtools.dialog_notification(config.get_localized_string(20000), f'Channel {channel_name} not found')
+            return
+        
+        search_item = Item(channel=channel_name, action='search', infoLabels={'mediatype': 'movie'})
+        search_item.fast_search = True
+        results = new_search(search_item.clone(text=search_text), channel)
+        
+        if not results:
+            platformtools.dialog_notification(config.get_localized_string(20000), 'No results found')
+            return
+        
+        best_match = None
+        search_text_lower = search_text.lower()
+        
+        for result in results:
+            if result.contentType != 'movie':
+                continue
+            
+            title = (result.contentTitle or result.title or '').lower()
+            result_year = str(result.year or result.infoLabels.get('year', ''))
+            
+            if search_text_lower == title and year and result_year == year:
+                best_match = result
+                break
+            elif search_text_lower == title and not best_match:
+                best_match = result
+            elif search_text_lower in title and not best_match:
+                best_match = result
+        
+        if not best_match and results:
+            for result in results:
+                if result.contentType == 'movie':
+                    best_match = result
+                    break
+        
+        if best_match:
+            logger.debug('Found movie match:', best_match.contentTitle or best_match.title)
+            best_match.action = 'findvideos'
+            findvideos(best_match)
+        else:
+            platformtools.dialog_notification(config.get_localized_string(20000), 'No matching movie found')
+            
+    except Exception as e:
+        import traceback
+        logger.error(traceback.format_exc())
+        platformtools.dialog_notification(config.get_localized_string(20000), str(e))
+
+
+def play_episode_direct(item):
+    """
+    Direct episode playback from TMDb Helper.
+    Searches for a TV show and plays the requested episode directly.
+    """
+    logger.debug('play_episode_direct called with:', item.tostring())
+    
+    channel_name = item.channel if item.channel else 'streamingcommunity'
+    search_text = item.text if item.text else ''
+    season = int(item.season) if item.season else 1
+    episode = int(item.episode) if item.episode else 1
+    year = str(item.year) if item.year else ''
+    
+    if not search_text:
+        platformtools.dialog_notification(config.get_localized_string(20000), 'No show name provided')
+        return
+    
+    try:
+        channel = importChannel(Item(channel=channel_name))
+        if not channel:
+            platformtools.dialog_notification(config.get_localized_string(20000), f'Channel {channel_name} not found')
+            return
+        
+        search_item = Item(channel=channel_name, action='search', infoLabels={'mediatype': 'tvshow'})
+        search_item.fast_search = True
+        results = new_search(search_item.clone(text=search_text), channel)
+        
+        if not results:
+            platformtools.dialog_notification(config.get_localized_string(20000), 'No results found')
+            return
+        
+        best_match = None
+        search_text_lower = search_text.lower()
+        
+        for result in results:
+            if result.contentType != 'tvshow':
+                continue
+            
+            title = (result.contentSerieName or result.contentTitle or result.title or '').lower()
+            result_year = str(result.year or result.infoLabels.get('year', ''))
+            
+            if search_text_lower == title and year and result_year == year:
+                best_match = result
+                break
+            elif search_text_lower == title and not best_match:
+                best_match = result
+            elif search_text_lower in title and not best_match:
+                best_match = result
+        
+        if not best_match and results:
+            for result in results:
+                if result.contentType == 'tvshow':
+                    best_match = result
+                    break
+        
+        if best_match:
+            logger.debug('Found show match:', best_match.contentSerieName or best_match.title)
+            
+            if hasattr(channel, 'find_episode'):
+                target_episode = channel.find_episode(best_match, season, episode)
+                if target_episode:
+                    logger.debug(f'Found episode directly S{season}E{episode}')
+                    target_episode.action = 'findvideos'
+                    findvideos(target_episode)
+                    return
+            
+            if hasattr(channel, 'episodios'):
+                episodes = channel.episodios(best_match)
+            elif hasattr(channel, 'episodes'):
+                episodes = channel.episodes(best_match)
+            else:
+                platformtools.dialog_notification(config.get_localized_string(20000), 'Channel does not support episodes')
+                return
+            
+            target_episode = None
+            for ep in episodes:
+                ep_season = ep.contentSeason or ep.infoLabels.get('season', 0)
+                ep_number = ep.contentEpisodeNumber or ep.infoLabels.get('episode', 0)
+                
+                if int(ep_season) == season and int(ep_number) == episode:
+                    target_episode = ep
+                    break
+            
+            if target_episode:
+                logger.debug(f'Found episode S{season}E{episode}')
+                target_episode.action = 'findvideos'
+                findvideos(target_episode)
+            else:
+                platformtools.dialog_notification(config.get_localized_string(20000), f'Episode S{season}E{episode} not found')
+        else:
+            platformtools.dialog_notification(config.get_localized_string(20000), 'No matching show found')
+            
+    except Exception as e:
+        import traceback
+        logger.error(traceback.format_exc())
+        platformtools.dialog_notification(config.get_localized_string(20000), str(e))
